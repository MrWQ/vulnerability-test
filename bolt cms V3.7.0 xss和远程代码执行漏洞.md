### bolt cms V3.7.0 xss和远程代码执行漏洞

1. #### 漏洞细节参考

   ```
   https://seclists.org/fulldisclosure/2020/Jul/4
   ```

2. #### 漏洞环境搭建

   github上下载对应版本，这里下载3.7.0.

   ```
   https://github.com/bolt/bolt/releases
   ```

   解压后需要重命名以下文件：

   ```
   mv .bolt.yml.dist .bolt.yml
   mv composer.json.dist composer.json
   mv composer.lock.dist composer.lock
   mv src/Site/CustomisationExtension.php.dist src/Site/CustomisationExtension.php 
   ```

   为了快速搭建这里使用phpstudy，开启apache和mysql

   ![](img/boltcms3.7.0/2.1.png)

   点击网站，创建站点，选择好php版本并创建数据库，记住域名、数据库名称、用户名和密码

   ![](img/boltcms3.7.0/2.2.png)

   配置数据库app/config/config.yml。填好数据库名称、用户名和密码然后保存

   ![](img/boltcms3.7.0/2.3.png)

   然后浏览器访问http://上面自己设置的域名/public即可到安装页面，第一次需要设置管理员账号和密码

   ```
   http://上面自己设置的域名/public    		
   http://上面自己设置的域名/public/bolt	# 管理地址
   ```

   ![](img/boltcms3.7.0/2.4.png)

   3. #### 漏洞分析

         1. XSS成因分析

         该漏洞存在于vendor/bolt/bolt/src/Controller/Backend/Users.php。有两个变量$user和$userEntity用于存储和使用以显示此代码中的用户数据。$userEntity在传递给$form->isValid（），这表明$user有未编码的输入和$userEntity是具有编码的输入。也就是说使用$user未对用户输入编码，使用$userEntity可以对用户输入编码。

         下面代码使用$user->getDisplayName（）而不是$userEntity->getDisplayName（），显示未编码的用户输入，所以导致XSS。

         ```
         switch ($action) {
                 case 'disable':
                     if ($this->users()->setEnabled($id, false)) {
                         $this->app['logger.system']->info("Disabled user
         '{$user->getDisplayname()}'.", ['event' => 'security']);
         
         
         $this->flashes()->info(Trans::__('general.phrase.user-disabled', ['%s'
         => $user->getDisplayname()]));
                     } else {
         
         $this->flashes()->info(Trans::__('general.phrase.user-failed-disabled',
         ['%s' => $user->getDisplayname()]));
                     }
                     break;
         
                 case 'enable':
                     if ($this->users()->setEnabled($id, true)) {
                         $this->app['logger.system']->info("Enabled user
         '{$user->getDisplayname()}'.", ['event' => 'security']);
         
         $this->flashes()->info(Trans::__('general.phrase.user-enabled', ['%s'
         => $user->getDisplayname()]));
                     } else {
         
         $this->flashes()->info(Trans::__('general.phrase.user-failed-enable',
         ['%s' => $user->getDisplayname()]));
                     }
                     break;
         
                 case 'delete':
                     if ($this->isCsrfTokenValid() && $this->users()->deleteUser($id)) {
                         $this->app['logger.system']->info("Deleted user
         '{$user->getDisplayname()}'.", ['event' => 'security']);
         
         $this->flashes()->info(Trans::__('general.phrase.user-deleted', ['%s'
         => $user->getDisplayname()]));
                     } else {
         
         $this->flashes()->info(Trans::__('general.phrase.user-failed-delete',
         ['%s' => $user->getDisplayname()]));
                     }
                     break;
         
                 default:
                     $this->flashes()->error(Trans::__('general.phrase.no-such-action-for-user',
         ['%s' => $user->getDisplayname()]));
             }
         ```

         2. 远程代码执行成因分析

            ```
             public function rename($path, $newPath)
                {
                    $path = $this->normalizePath($path);
                    $newPath = $this->normalizePath($newPath);
                    $this->assertPresent($path);
                    $this->assertAbsent($newPath);
            
                    $this->doRename($path, $newPath);
                }
            ```

            normalizePath（）函数在第823行acts的同一文件中定义作为Flysystem的normalizePath（）函数的包装器。已经习惯了

            获取文件的“真实”路径。这用于验证文件位置等等。例如，./somedir/../text.txt == ./text.txt == text.txt

            所以'./text.txt' 传递给此函数，它返回 'text.txt'

            所以，从文件名 'backdoor.php/.' 将其传递给normalizePath（）它返回 'backdoor.php' ,这正是我们所需要的。

            所以数据流看起来，首先是值'backdoor.php/.' 传递给validateFileExtension（）返回NULL，因为后面没有文本最后一个点。所以，extesion过滤器被绕过了。接下来，相同的值是传递给normalizePath（），它删除最后一个“/.”，因为它看起来像它是指向当前目录的路径。最后，文件被重命名为'backdoor.php' 

            

   3. #### 漏洞测试

      ##### 1. xss

      构造payload

      ```
      POST /preview/page HTTP/1.1
      Host: localhost
          contenttype=pages&title=title&slug=testpage1&teaser=teaser1&body=<script>alert(1)</script>&id=151
      ```

      ![](img/boltcms3.7.0/2.5.png)

      ![](img/boltcms3.7.0/2.6.png)

   4. ##### 远程代码执行

   创建一个文件，然后编辑这个文件，写入木马保存。

   ![](img/boltcms3.7.0/2.7.png)

   ![](img/boltcms3.7.0/2.8.png)

   ```
   然后将shell.html重命名危shell.html.php\.
   ```

   ![](img/boltcms3.7.0/2.9.png)

   即可变成shell.html.php

   ![](img/boltcms3.7.0/2.10.png)

   访问该文件即可执行命令

   ![](img/boltcms3.7.0/2.11.png)

   5. #### 影响版本

      Bolt CMS<= 3.7.0


   6. #### 防御方案


         1. XSS

            使用具有编码值的变量来显示用户信息。使用$userEntity而不是$user

         2. 重命名时更改数据流。先把数据传过来normalizePath（）数据，然后通过validateFileExtension（）。这样，验证函数验证最终值。


